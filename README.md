# Microbanking and Interest Management System (MIMS)

To get started with the project, read `TUTORIAL.md`

A full-stack web application built for B-Trust Microfinance Bank to digitize core banking operations, including customer management, savings accounts, fixed deposits, and automated interest calculations.

## ğŸš€ Tech Stack

### Backend (API Server)
*   **Runtime:** Node.js
*   **Framework:** Express.js
*   **ORM:** Prisma
*   **Database:** PostgreSQL
*   **Authentication:** JWT (JSON Web Tokens)
*   **Password Hashing:** bcryptjs

### Frontend (User Interface)
*   **Library:** React
*   **Build Tool:** Vite (recommended for faster setup)
*   **Styling:** Tailwind CSS

### Development & Deployment
*   **Environment Variables:** dotenv
*   **Containerization:** Docker (optional but recommended)
*   **Platform:** Render / Railway / Vercel (for easy deployment)

## ğŸ¤” Why This Stack?

| Technology | Why We Chose It | Why Not [Alternative]? |
| :--- | :--- | :--- |
| **PostgreSQL** | Offers robust ACID compliance, advanced features (JSON support, powerful indexing), and excellent support for complex queries and reports required for a financial system. | **MySQL:** While MySQL is great, PostgreSQL's feature set is more advanced for this use case. **MongoDB:** A NoSQL database is not suitable for a transaction-heavy system requiring strict relational integrity and ACID properties. |
| **Node.js + Express** | Asynchronous by nature, making it efficient for handling multiple concurrent transactions. JavaScript across the stack (with React) simplifies development. | **Django (Python):** While a great framework, our team had more familiarity with Node.js, allowing for faster development and easier context switching between frontend and backend. |
| **Prisma** | Provides a type-safe and intuitive API for database access, reducing SQL boilerplate and potential errors. Its migration system is simple and reliable. | **Raw SQL / Sequelize:** Prisma offers a cleaner, more modern developer experience compared to older ORMs or writing raw SQL for every query. |
| **React** | The most popular frontend library with a huge ecosystem. Allows us to build a dynamic, component-based UI quickly, even with minimal state management needs. | **Vue.js / Angular:** React has a larger community and resource pool. For a lightweight UI, React with simple hooks is perfectly sufficient and easier to learn. |
| **JWT** | Stateless, scalable, and works seamlessly with modern frontend frameworks like React. Easier to implement than session-based auth for a REST API. | **Session Cookies:** JWTs are a more standard choice for decoupled API-backend and frontend-client architectures. |

## ğŸ—ï¸ System Architecture (How the App is Built)

The application follows a client-server model with three main layers:

1.  **Frontend (Client):** A React application running in the user's browser. It displays forms and data, and sends HTTP requests to the backend.
2.  **Backend (Server):** A Node.js/Express application. It receives requests from the frontend, contains all the business logic (e.g., "can this withdrawal proceed?"), and communicates with the database.
3.  **Database:** A PostgreSQL database. It securely stores all data (customers, accounts, transactions) and enforces relationships and rules.

```
[User's Browser]
       |
       | (HTTPS Requests / JSON Data)
       |
[Node.js + Express Server]  <-> [Prisma] <-> [PostgreSQL Database]
       |
       | (HTTP Responses / JSON Data)
       |
[React App (UI)]
```

### Data Flow for a Deposit:
1.  Agent fills out a deposit form in the React UI and clicks "Submit".
2.  The React app sends a `POST /api/transactions` request with the data (e.g., `{ accountId: 5, amount: 1000, type: 'DEPOSIT' }`) to the Express server.
3.  The Express server receives the request. It uses Prisma to:
    a. Find the account.
    b. Check business rules (e.g., is the account active?).
    c. **Create a new transaction record** and **update the account's balance** in a single database transaction (to ensure data never gets corrupted).
4.  Prisma executes the operations against the PostgreSQL database.
5.  The Express server sends a success response back to the React app.
6.  The React app updates the UI to show the agent that the deposit was successful.

## ğŸ“ Project Structure (Outline)

```
mims-app/
â”œâ”€â”€ backend/                 # Node.js/Express API
â”‚   â”œâ”€â”€ node_modules/
â”‚   â”œâ”€â”€ prisma/
â”‚   â”‚   â”œâ”€â”€ schema.prisma   # Your Database Schema
â”‚   â”‚   â””â”€â”€ migrations/     # Generated by Prisma
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ routes/         # API Routes (e.g., /customers, /transactions)
â”‚   â”‚   â”œâ”€â”€ middleware/     # Auth, error handling
â”‚   â”‚   â””â”€â”€ index.js        # Server entry point
â”‚   â”œâ”€â”€ .env                # Environment variables (DB URL, JWT secret)
â”‚   â””â”€â”€ package.json
â”‚
â””â”€â”€ frontend/               # React Application
    â”œâ”€â”€ node_modules/
    â”œâ”€â”€ public/
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ components/     # Reusable UI components
    â”‚   â”œâ”€â”€ pages/         # Page components (Dashboard, CustomerPage)
    â”‚   â””â”€â”€ App.jsx
    â”œâ”€â”€ .env
    â””â”€â”€ package.json
```

This structure keeps the backend and frontend separate, which is best practice and makes deployment easier.
